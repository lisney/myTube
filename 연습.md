# 프로미스 연습
```
function makeRequest(location){
    console.log(`${location} 전달`)
    return new Promise((resolve, reject)=>{
        if(location ==='Google'){
            resolve('구글 전달')
        }else{
            reject('니주글래')
        }
    })
}

function processRequest(response){
    return new Promise((resolve, reject)=>{
        resolve(`${response}를 받았다`)
    })
}

async function doWork(){
    try{
        const response = await makeRequest('Gogle')
        console.log(response)
        const processResponse = await processRequest(response)
        console.log(processResponse)
    }catch(err){
        console.log(err)
    }
}
doWork()
```

# raycaster 연습
```
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        #c{
            display: block;
            width: 600px;
            height: 300px;
        }
    </style>
</head>
<body>
    <video src="" width="300" height="300" autoplay muted></video>
    <canvas id="c"></canvas>

    <script type="module">
        const video = document.querySelector('video')
        function startVideo(){
            navigator.mediaDevices.getUserMedia({video})
            .then(stream=>video.srcObject = stream)
            .catch(err=>console.log(err))
        }
        startVideo()

        //캔버스 2D
        const ctx = document.createElement('canvas').getContext('2d')
        ctx.canvas.width = 300
        ctx.canvas.height = 300
        document.body.appendChild(ctx.canvas)

        ctx.fillStyle = 'red'
        ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height)

        const img = new Image()
        img.addEventListener('load',()=>{
            ctx.drawImage(img, 10, 10, ctx.canvas.width-20, ctx.canvas.height-20)
        })
        img.src = '../4g2.jpg'

        //three JS
        import * as THREE from './three.module.js'

        const canvas = document.querySelector('#c')
        let renderer, texture, scene, cubes, camera

        function main(){
            renderer = new THREE.WebGLRenderer({canvas})
            scene = new THREE.Scene()
            scene.background = new THREE.Color(0x555555)

            camera = new THREE.PerspectiveCamera(75, 2, 1, 10)
            camera.position.set(0,0,2)
            {
                const light = new THREE.DirectionalLight(0xffffff, 1)
                light.position.set(-1,2,4)
                scene.add(light)
            }

            const geometry = new THREE.BoxGeometry(1,1,1)

            function rand(min, max){
                if(max ===undefined){
                    max = min
                    min = 0
                }
                return min + (max -min)*Math.random()
            }
            texture = new THREE.CanvasTexture(ctx.canvas)
            const textureVideo = new THREE.VideoTexture(video)

            function makeInstance(x){
                const material = [
                        new THREE.MeshPhongMaterial({color:`hsl(${rand(360)|0}, ${rand(50,100)|0}%, 50%)`}),
                        new THREE.MeshPhongMaterial({map: texture}),
                        new THREE.MeshPhongMaterial({color:`hsl(${rand(360)|0}, ${rand(50,100)|0}%, 50%)`}),
                        new THREE.MeshPhongMaterial({map: texture}),
                        new THREE.MeshPhongMaterial({map: textureVideo}),
                        new THREE.MeshPhongMaterial({color:`hsl(${rand(360)|0}, ${rand(50,100)|0}%, 50%)`}),
                    ] 

                const cube = new THREE.Mesh(geometry, material)
                cube.position.set(x,0,0)
                scene.add(cube)

                return cube
            }

            cubes =[
                makeInstance(-2),
                makeInstance(0),
                makeInstance(2),
            ]

            function resizeRendererToDisplaySize(renderer){
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;

                const needResize = width!==canvas.width||height!==canvas.height;

                if(needResize){
                    renderer.setSize(width, height, false)
                }

                return needResize
            }

            function render(time){
                time *= 0.001

                if(resizeRendererToDisplaySize(renderer)){
                    camera.aspect = canvas.width/canvas.height;
                    camera.updateProjectionMatrix()
                }

                cubes.forEach((c,i)=>{
                    const speed = 1 + i*.1
                    const rot = speed *time

                    c.rotation.set(rot,rot,0)
                })
                texture.needsUpdate = true

                renderer.render(scene, camera)

                requestAnimationFrame(render)
                
            }
            requestAnimationFrame(render)

        }

        main()
        
        // const pickPosition = {x:-1, y:-1}
        let pickPosition = new THREE.Vector2()
        const domRect = canvas.getBoundingClientRect()

        function choose(event){
            let Sx = event.clientX -domRect.x
            let Sy = event.clientY -domRect.y
            pickPosition.x = (Sx/canvas.width)*2 -1;
            pickPosition.y = (Sy/canvas.height)*-2 +1

            let raycaster = new THREE.Raycaster()
            raycaster.setFromCamera(pickPosition, camera)
            let intersects = raycaster.intersectObjects(scene.children)
            console.log(domRect.width,intersects)

            if(intersects.length>0){
                intersects[0].object.material[1].transparent = true
                intersects[0].object.material[2].side = THREE.DoubleSide
                intersects[0].object.material[1].opacity = 0.4
            }

        }

        canvas.addEventListener('click', choose)



    </script>
</body>
</html>
```

# 이름표를 붙여 1
    <div id="container">
        <canvas id="c"></canvas>
        <div id="labels"></div>
    </div>

>>class-----------------------------------------------
     #container{
         position: relative;
         width: 600px;
         height: 300px;

     }
     #c{
         display: block;
         width: 100%;
         height: 100%;
     }
     #labels{
         position: absolute;
         left: 0;
         top: 0;
         color: white;
     }

     #labels > div{
         position: absolute;
         left: 0;
         top: 0;
         cursor: pointer;
         font-size: xx-large;
         user-select: none;
         text-shadow: 1px 1px 5px black;
     }

     #labels > div:hover{
        color: yellow;
     }

>> script OrbitControls

        import {OrbitControls} from './OrbitControls.js'

            camera = new THREE.PerspectiveCamera(50,2,.1,10)
            camera.position.set(0,0,5)
            scene.add(camera)
            {
                const light = new THREE.PointLight(0xffffff, .3)
                camera.add(light)
            }

            const controls = new OrbitControls(camera,canvas)
            controls.target = scene.position
            controls.update()

>> makeInstance

            const labelContainerElem = document.querySelector('#labels')

            function makeInstance(x, name){
                const material = new THREE.MeshPhongMaterial({color:`hsl(${rand(360)|0}, ${rand(50,100)|0}%, 70%) `})
                // const material = new THREE.MeshPhongMaterial({map:texture})
                const cube = new THREE.Mesh(geometry, material)

                cube.position.set(x,0,0)
                scene.add(cube)

                const elem = document.createElement('div')
                elem.textContent =name;
                labelContainerElem.appendChild(elem)

                return {cube, elem}
            }

            cubes =[
                makeInstance(-2, '4G2'),
                makeInstance(0, 'Kyoko'),
                makeInstance(2,'Dakako')
            ]


>> tempV

            const tempV = new THREE.Vector3()

                cubes.forEach((c,i)=>{
                    const {cube, elem} = c;
                    const speed = 1 + i*.1;
                    const rot = speed * time

                    cube.rotation.set(rot, rot, 0)

                    cube.updateWorldMatrix(true, false)
                    cube.getWorldPosition(tempV)

                    tempV.project(camera)

                    const x = (tempV.x*.5 + .5)*canvas.clientWidth;
                    const y = (tempV.y*-.5 + .5)*canvas.clientHeight;

                    elem.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px`;
                })
