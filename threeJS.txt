############  반응형 디자인

### 계단 현상 없애기: setSize 메서드(drawingbuffer의 크기를 조절)
-  해상도를 canvas의 디스플레이 크기에 맞춘다.

            function resizeRendererToDisplaySize(renderer){
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !==width||canvas.height!=height;
                if(needResize){
                    renderer.setSize(width,height, false);
                    /*false 제어를 직접하지 않고, CSS가 하게한다*/
                }
                return needResize;
            }

> function render(time) 바꾼다

            function render(time){
                time *=0.0001;

                if(resizeRendererToDisplaySize(renderer)){
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth/canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }
                renderer.render(scene, camera);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }



########## GUI
>    import {GUI} from './dat.gui.module.js';
    let cubes; //api에서 사용하기 위해서는 미리 선언하여야한다

    let api ={
        boxWidth:1,
        state:'ball',
        switch:false,
        reset:function(){
            cubes[1].scale.x =1;
            cubes[1].scale.y =1;
            cubes[1].scale.z =1;
        }
    };


>        const gui = new GUI();


>폴더
        var box = gui.addFolder('Cube');
        box.add(cubes[1].scale, 'x', 0, 3).name('Width').listen();
        box.add(cubes[1].scale, 'y', 0, 3).name('Height').listen();
        box.add(cubes[1].scale, 'z', 0, 3).name('Length').listen();
        box.add(cubes[1].material, 'wireframe').listen();
        box.open();
        box.add(api, 'reset');

> 라이트
            gui.add(light, 'intensity', 0,2,.1);



> AmbientLight 생성( dat.GUI로 제어)
> const light = new THREE.AmbientLight(color, intensity);

dat.GUI로 색상을 조정하려면 간단한 헬퍼 클래스가 필요합니다. 이 클래스는 색상을 CSS hex(예: #FF8844) 값으로 변경해 dat.GUI에 넘겨주는 역할을 할 거예요. 그리고 dat.GUI가 클래스의 속성을 지정할 때, 이를 조명에 직접 지정하도록 합니다.

>  import {GUI} from './js/dat.gui.module.js';

> 클래스
        class ColorGUIHelper{
            constructor(object, prop){
                this.object = object;
                this.prop = prop;
            }
            get value(){
                return `#${this.object[this.prop].getHexString()}`;
            }
            set value(hexString){
                this.object[this.prop].set(hexString);
            }
        }

>         const gui = new GUI();
        gui.addColor(new ColorGUIHelper(light, 'color'),'value').name('color');
        gui.add(light, 'intensity', 0,2,0.1);


> HemisphereLight 천정과 바닥색이 다른 조명
        const skyColor = 0xb1e1ff; //하늘색
        const groundColor = 0xb97a20; // 오렌지 브라운
        const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);

        gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('하늘색');
        gui.addColor(new ColorGUIHelper(light, 'groundColor'), 'value').name('땅색');

>> DirectionalLightHelper 사용하여 가시성

        const helper = new THREE.DirectionalLightHelper(light);
        scene.add(helper);

> Vector3 객체를 인자로 받아, dat.GUI로 이 객체의 x, y, z 속성을 조정하는 함수
        function makeXYZGUI(gui, vector3, name, onChangeFn){
            const folder = gui.addFolder(name);
            folder.add(vector3, 'x', -10, 10).onChange(onChangeFn);
            folder.add(vector3, 'y', 0,10).onChange(onChangeFn);
            folder.add(vector3, 'z', -10,10).onChange(onChangeFn);
            folder.open();
        }

> 헬퍼 객체를 사용할 때는 헬퍼 객체의 update 메서드를 수동으로 호출해줘야 합니다.
        function updateLight(){
            light.target.updateMatrixWorld();
            helper.update();
        }
        updateLight();

> GUI에서도 update 메서드를 실행해 주어야한다.
        makeXYZGUI(gui, light.position, '위치', updateLight);
        makeXYZGUI(gui, light.target.position, '타깃', updateLight);





###########  OrbitControls 불필요한 랜더링 없애기 예


# preventDefalult() //
html 에서 a 태그나 submit 태그는 고유의 동작이 있다. 페이지를 이동시킨다거나 form 안에 있는 input 등을 전송한다던가 그러한 동작이 있는데 e.preventDefault 는 그 동작을 중단시킨다.

########## OBJ Loader 모듈방식이므로 jsm 폴더에서 찾아야한다
> 모듈을 열어 three.module.js 경로를 바꿔줘야한다.

######### camera.lookAt(new THREE.Vector3(0,0,0));

######### constraint controls 
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0,0,0);
        controls.minPolarAngle =Math.PI/3;
        controls.maxPolarAngle =Math.PI/2;
        controls.enableZoom =false;
        controls.minAzimuthAngle = -Math.PI/2;
        controls.maxAzimuthAngle = Math.PI/2;

######### 평면 생성
        const planeSize= 5;
        const loader = new THREE.TextureLoader();
        const texture = loader.load('./4g2.jpg');
        
        const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
        const planeMat = new THREE.MeshToonMaterial({
            map:texture,
            side:THREE.DoubleSide,
        });
        const mesh = new THREE.Mesh(planeGeo, planeMat);
        mesh.rotation.x = Math.PI*-.5;
        scene.add(mesh);
        mesh.position.set(0,-1,0);

######## 배경 투명, CSS 배경으로 합성
        const renderer = new THREE.WebGLRenderer({canvas, alpha:true,});

######## 배경, 컬러
        scene.background = new THREE.Color('white');


####### 멀티라이트 함수  ...pos 
        function addLight(...pos){
            const color = 0xffffff;
            const intensity = 0.7;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(...pos);
            scene.add(light);
        }

        addLight(-1,2,4);
        addLight(1,-1,-2);

###### 재질 투명
            const material = new THREE.MeshPhongMaterial({color,opacity:0.5,transparent:true,side:THREE.DoubleSide});

##### 재질  alphaTest
        const planeMat = new THREE.MeshPhongMaterial({
            map:texture,
            side:THREE.DoubleSide,
            alphaTest:0.5,
        });

###### 카메라에 라이트 달기
카메라에`PointLight '와 같은 자식 오브젝트가있는 경우 장면에 카메라를 추가해야합니다.

scene.add( camera );


######## 비동기 처리
> function 앞에 async를 붙이면 해당 함수는 항상 프라미스를 반환합니다.
> await는 async 함수 안에서만 동작

    async function f(){
        let promise = new Promise((resolve, reject)=>{
            setTimeout(()=>resolve("완료!"),2000)
        });
        let result = await promise;

        alert(result);
    }
    f();


##### 조명 GUI 사용 dat.gui.module 
> gui 사용을 위한 Helper Class

        class ColorGUIHelper{
            constructor(object, prop){
                this.object = object;
                this.prop = prop;
            }
            get value(){
                return `#${this.object[this.prop].getHexString()}`; // 색상을 CSS hex값으로 변경
            }
            set value(hexString){
                this.object[this.prop].set(hexString);
            }
        }

> gui 생성

        const gui = new GUI();
        gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
        gui.add(light, 'intensity', 0,2,0.1);


###### GLTF 내보내기 Blender Bone Aniamtion
> 각각 Track 클립 넣기 >  클립 교차되지 않게 위치 옮기기
> 이름 바꾸기 : Animation Data 에서 애니메이션을 선택한 후 이름바꾼다
> 시작 프레임 위치로 옮긴 후 Export




#################################################
##### 인터랙티브 gltf, gui, blender
<!DOCTYPE html>
<html lang="ko">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <meta http-equiv="X-UA-Compatible" content="ie=edge">
 <title>title</title>
 <style>
     *{
         margin: 0;
         padding: 0;
         box-sizing: border-box;
     }
     section{
         width: 100%;
         min-height: 100vh;
         background: #121212;
         display: flex;
         justify-content: center;
         align-items: center;
         overflow: hidden;
     }
     section:before{
         content: '';
         position: fixed;
         width: 100%;
         height: 100%;
         clip-path: circle(65% at 100% -30%);
         background: tomato;
         top: 0;
         left: 0;
     }
     #a{
         width: 800px;
         height: 400px;
         background: rgba(255,255,255,0.1);
         z-index: 2;
         box-shadow: 0 0 10px rgba(0,0,0,0.2);
         backdrop-filter: blur(15px);
     }
     .gui{
         position: fixed;
         width: 100px;
         height: 500px;
         right: 0;
         top: 0;
         display: block;
         z-index: 3;
     }
 </style>
</head>
<section>
    <canvas id="a">
    </canvas>
    <div class="gui"></div>
</section>

<script type="module">
    import {GLTFLoader} from './js/GLTFLoader.js';
    import * as THREE from './js/three.module.js';
    import {OrbitControls} from './js/OrbitControls.js';
    import {GUI} from './js/dat.gui.module.js';
    
    let mixer;
    let model;
    const api ={state:'ball01', switch:false, reverse:false,
    switch:function(){
        model.traverse((child)=>{
        if(child.name=='BallA'){
            child.visible = !child.visible;
            console.log(child.name+"하이");
        }
        });
    }

};

    
    function main(){
        let clock = new THREE.Clock();
        
        const canvas = document.querySelector('#a');
        const renderer = new THREE.WebGLRenderer({canvas,alpha:true});
        
        const scene = new THREE.Scene();
        
        const fov = 75;
        const aspect = 2;
        const near = 0.1;
        const far = 100;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0,0,3);
        
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0,0,0);
        controls.update();
        
        
        const color=0xffffff;
        const intensity = 1;
        const light = new THREE.DirectionalLight(color, intensity);
        light.position.set(-1,2,4);
        scene.add(light);
        
        class ColorGUIHelper{
            constructor(object, prop){
                this.object = object;
                this.prop = prop;
            }
            get value(){
                return `#${this.object[this.prop].getHexString()}`; //색상 hex값으로 변경
            }
            set value(hexString){
                this.object[this.prop].set(hexString);
            }
        }
        
        const gui = new GUI();
        gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
        gui.add(light, 'intensity', 0,2,0.1);
        
        const gltfLoader = new GLTFLoader();
        const url ='./sagiri.gltf';

        const guiDiv = document.querySelector('.gui');
        guiDiv.appendChild(gui.domElement);

        
        
        gltfLoader.load(url,(gltf)=>{
            model = gltf.scene;
            createGUI(model, gltf.animations);
            // mixer.clipAction(gltf.animations[0]).play();
            // gltf.animations.forEach((clip)=>{mixer.clipAction(clip).play();})
            scene.add(model);

        });
        
        // const api ={state:'ball01'};
        function createGUI(model, animations){
            const states = ['ball01', 'ball02'];
            
            const statesFolder = gui.addFolder('States');
            
            mixer = new THREE.AnimationMixer(model);
            
            const clipCtrl = statesFolder.add(api, 'state').options(states);
            statesFolder.open();
            
            
            clipCtrl.onChange(function(e){
                let clip = THREE.AnimationClip.findByName(animations,e);
                mixer.clipAction(clip).loop =THREE.LoopOnce;
                // mixer.clipAction(clip).loop =THREE.LoopPingPong;
                mixer.clipAction(clip).clampWhenFinished =true;
                mixer.clipAction(clip).enable = true;
                mixer.clipAction(clip).play().reset();
                
                
            })
            const swCtrl = gui.add(api,'switch').name("Action");
            const btnCtrl = gui.add(api,'reverse').name("Reverse");
            
            let clip = THREE.AnimationClip.findByName(animations,'ball02');


            
            
            btnCtrl.onChange(function(e){
                if(e==true){
                    mixer.clipAction(clip).reset();
                    mixer.clipAction(clip).clampWhenFinished =true;
                    mixer.clipAction(clip).timeScale = 1;
                    mixer.clipAction(clip).setLoop(THREE.LoopOnce,1);
                    mixer.clipAction(clip).play();
                }else{
                    mixer.clipAction(clip).reset();
                    mixer.clipAction(clip).paused = false;
                    mixer.clipAction(clip).timeScale = -1;
                    mixer.clipAction(clip).setLoop(THREE.LoopRepeat, 1);
                    mixer.clipAction(clip).play();
                }
                // mixer.clipAction(clip).reset();

            })

            
        }
        

        function resizeRendererToDisplaySize(renderer){
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width!==width||canvas.height!==height;
            if(needResize){
                renderer.setSize(width, height, false);
            }

            return needResize;
        }

        function render(){
            if(resizeRendererToDisplaySize(renderer)){
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth/canvas.clientHeight;
                camera.updateProjectionMatrix();
            }
            let dt = clock.getDelta();
            if(mixer) mixer.update(dt);

            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }
        render();

        controls.addEventListener('change', render);

    }


    main();


</script>
<body>
</body>
</html>


######## GUI z-index
</head>
<section>
    <canvas id="a">
    </canvas>
    <div class="gui"></div>
</section>
------------------------------------
     .gui{
         position: fixed;
         width: 100px;
         height: 500px;
         right: 0;
         top: 0;
         display: block;
         z-index: 3;
     }

---------------------------------------
        const guiDiv = document.querySelector('.gui');
        guiDiv.appendChild(gui.domElement);



##### visible 
            swCtrl.onChange((e)=>{
                model.traverse((child)=>{
                if(child.name=='BallA'){
                    child.visible = e;
                    console.log(child.name);
                }
            });
            });

##### visible , switch GUI
    switch:function(){
        model.traverse((child)=>{
        if(child.name=='BallA'){
            child.visible = !child.visible;
            console.log(child.name+"하이");
        }
        });




##### 배경
        const loader = new THREE.TextureLoader();
        const bgTexture = loader.load('./env.jpg');
        scene.background = bgTexture;


##### 3D 배경
        const loader = new THREE.TextureLoader();
        const texture = loader.load('./env.jpg',()=>{
            const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
            rt.fromEquirectangularTexture(renderer, texture);
            scene.background = rt.texture;
        });

> texture 를 envMap으로 사용
> json material 수정
                "metallicFactor" : 0.5,
                "roughnessFactor" :0.2
> 전역 변수 let rt
> 이벤트 시
 child.material.envMap = rt.texture;

>> api function 예
    switch:function(){
        model.traverse((child)=>{
        if(child.name=='BallA'){
            // child.visible = !child.visible;
            // console.log(child.name+"하이");
            if(envToggle){
                child.material.envMap = rt.texture;
            }else{
                child.material.envMap = null;
            }
            envToggle = !envToggle;
        }
        });
    }

#####  배경토글 체크버튼
>api 추가 >   bgToggle:true,

> gui 추가
>             const bgCtrl = gui.add(api,'bgToggle').name("배경").onChange((value)=>{
                if(value){
                    scene.background = rt.texture;
                }else{
                    scene.background = null;
                }
            });


######## 
바닐라 JS가 아닌 TypeScript이지만 as그 자체로는 Type Assertion 이라고 하며 컴파일러에게 무언가를 유형으로 처리하도록 지시하는 것입니다.
var a = 'TEST STRING'
var b = a as string; 
다음과 동일합니다.

var a = 'TEST STRING'
var b = <string> a; 
------------------------------------------------------

const loader = new GLTFLoader()
loader.load(
    'models/monkey.glb',
    function (gltf) {
        gltf.scene.traverse(function (child) {
            if ((child as THREE.Mesh).isMesh) {
                if ((child as THREE.Mesh).name === "Suzanne") {
                    const mesh = new THREE.Mesh((child as THREE.Mesh).geometry.clone(), new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
                    mesh.position.set(2, 1.5, -3)
                    mesh.geometry.scale(1.15, 1.15, 1.15)
                    scene.add(mesh)//adding only the monkey mesh to the scene and ignoring everything else inside the gltf

                    const cubeCSG = CSG.fromGeometry(cubeMesh.geometry.clone().translate(-.5, 0, 0));
                    const monkeyMeshCSG = CSG.fromMesh(mesh);

                    const cubeMonkeyMeshIntersectCSG = cubeCSG.intersect(monkeyMeshCSG.clone());
                    cubeMonkeyMeshIntersect = CSG.toMesh(cubeMonkeyMeshIntersectCSG, new THREE.Matrix4());
                    cubeMonkeyMeshIntersect.material = material
                    cubeMonkeyMeshIntersect.position.set(-3, 1.5, 0)
                    scene.add(cubeMonkeyMeshIntersect)

                    const cubeMonkeyMeshSubtractCSG = cubeCSG.subtract(monkeyMeshCSG.clone());
                    cubeMonkeyMeshSubtract = CSG.toMesh(cubeMonkeyMeshSubtractCSG, new THREE.Matrix4());
                    cubeMonkeyMeshSubtract.material = material
                    cubeMonkeyMeshSubtract.position.set(0, 1.5, 0)
                    scene.add(cubeMonkeyMeshSubtract)

                    const cubeMonkeyMeshUnionCSG = cubeCSG.union(monkeyMeshCSG.clone());
                    cubeMonkeyMeshUnion = CSG.toMesh(cubeMonkeyMeshUnionCSG, new THREE.Matrix4());
                    cubeMonkeyMeshUnion.material = material
                    cubeMonkeyMeshUnion.position.set(3, 1.5, 0)
                    scene.add(cubeMonkeyMeshUnion)

                    modelsReady = true
                }
            }
        })
    },
    (xhr) => {
        console.log((xhr.loaded / xhr.total * 100) + '% loaded')
    },
    (error) => {
        console.log(error);
    }
);


###############################################
GUI 박스 변환

        let cube;
        const api ={
            click:function(){
                cube.visible = !cube.visible;
            },
            position:'center',
            light:true,
        }


                const loader = new GLTFLoader();
                
                    loader.load('./gltf/girlA.gltf',(gltf)=>{
                        const root = gltf.scene;
                        scene.add(root);

                        box = root.getObjectByName('Box');
                    });

> GUI
            const gui = new GUI()

            const group = gui.addFolder("박스스");
            group.add(api, 'click');
            group.add(api, 'position',['left','center','right']).onChange(position=>{
                if(position=='left')cube.position.set(-2,0,0);
                else if(position=='center') cube.position.set(0,0,0);
                else cube.position.set(2,0,0);
                
            });

            group.open();
        function updateCamera(){
            camera.updateProjectionMatrix()
        }
        gui.add(camera,'fov', 20,75).onChange(updateCamera);
                    

> Animate
            function animate(time){
                time *= 0.001;

                if(cube){
                    cube.rotation.set(time, time,0);
                }

                renderer.render(scene, camera);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);



########## HTML 요소를 3D로
    <div id="container">
        <canvas id="c"></canvas>
        <div id="label"></div>
    </div>

>CSS
     #container{
         position: relative;
         width: 600px;
         height: 300px;
     }
     #c{
         width: 100%;
         height: 100%;
         display: block;
     }
     #label{
         position: absolute;
         left: 0;
         top: 0;
     }
     #label > div{
         left: 0;
         top: 0;
         cursor: pointer;
         font-size: x-large;
         text-shadow: 1px 1px 3px black;
     }
     #label > div:hover{
         color: red;
     }

> Script
           const elem = document.createElement('div');
            elem.textContent = "하마베미나미";
            labelContainerElem.appendChild(elem);
            
            const tempV = new THREE.Vector3();
            
            function animate(time){
                time *= 0.001;
                
                if(resizeRendererToDisplaySize(renderer)){
                    camera.aspect = canvas.clientWidth/canvas.clientHeight;
                    
                    camera.updateProjectionMatrix();
                }

   
> tempV.project(camera) 하면 위치가        
> x(-1~1), y(1~-1) > 곱하기 0.5 > -0.5 ~ 0.5 >더하기 0.5 > 0 ~ 1 >곱하기 width > 화면 상 위치
> updateWorldMatrix ( updateParents : Boolean, updateChildren : Boolean )
                if(cube){
                    cube.rotation.set(time, time,0);
                    cube.updateWorldMatrix(true, false);
                    cube.getWorldPosition(tempV)

                    tempV.project(camera);

                    const x = (tempV.x *.5 + .5)* canvas.clientWidth;
                    const y = (tempV.y *-.5 + .5)* canvas.clientHeight;

                    elem.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;

                }

> 절두체를 벗어나면 안보이게
                if(Math.abs(tempV.z)>1){
                    elem.style.display = 'none';
                }else{
                    elem.style.display = 'block';
                }



####### RayCaster 오브젝트 피킹
>scene.background, Object3D
        scene.background = new THREE.Color('dodgerblue');
> 회전용 폴
        const cameraPole = new THREE.Object3D();
        scene.add(cameraPole);
        cameraPole.add(camera);


> 랜덤
        function rand(min, max){
            if(max ===undefined){
                max = min;
                min = 0;
            }
            return min + (max - min)*Math.random();
        }
> 랜덤 컬러, 변형, '|'(이진곱셈, 결과 정수 반환), ++i(더하고, 반환), i++(보관하고, 더하고, 반환)
        function randomColor(){
            return `hsl(${rand(360)|0}, ${rand(50,100)|0}%, 50%)`;
        }

        const numObjects = 20;
        for(let i = 0; i < numObjects; ++i){
            const material = new THREE.MeshPhongMaterial({color:randomColor()});
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            cube.position.set(rand(-5, 5), rand(-5,5), rand(-5,5));
            cube.rotation.set(rand(Math.PI), rand(Math.PI),0)
            const rands = rand(2);
            cube.scale.set(rands, rands, rands);
        }

> 랜덤 컬러 2
            function createMaterial(){
                const material = new THREE.MeshPhongMaterial({
                    side:THREE.Doubleside,
                });

                const hue = Math.random();
                const saturation = 1;
                const luminance = .5;
                material.color.setHSL(hue, saturation, luminance);




###########  기초
>  input range
<input type="range" value="0" min="0" max="1000">



############# 박스지오메트리 boxgeometry 수정
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Three.js Geometry Browser</title>
    <link rel="shortcut icon" href="../../files/favicon.ico" />
    <link rel="stylesheet" type="text/css" href="../../files/main.css">
    <style>
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      #newWindow {
        display: block;
        position: absolute;
        bottom: 0.3em;
        left: 0.5em;
        color: #fff;
      }
    </style>
  </head>
  <body>

    <!-- <a id='newWindow' href='./geometry-browser.html' target='_blank'>Open in New Window</a> -->

    <script type="module">
      import {
        BoxGeometry,
        BufferGeometry,
        Color,
        DoubleSide,
        Float32BufferAttribute,
        Group,
        LineSegments,
        LineBasicMaterial,
        Mesh,
        MeshPhongMaterial,
        PerspectiveCamera,
        PointLight,
        Scene,
        Vector2,
        Vector3,
        WireframeGeometry,
        WebGLRenderer,
        GridHelper,
      } from './three.module.js';

      import { GUI } from './dat.gui.module.js';
      import { OrbitControls } from './OrbitControls.js';
      // import { ParametricGeometries } from '../../examples/jsm/geometries/ParametricGeometries.js';

      const twoPi = Math.PI * 2;

      function updateGroupGeometry( mesh, geometry ) {

        mesh.children[ 0 ].geometry.dispose();
        mesh.children[ 1 ].geometry.dispose();

        mesh.children[ 0 ].geometry = new WireframeGeometry( geometry );
        mesh.children[ 1 ].geometry = geometry;

        // these do not update nicely together if shared

      }



      const guis = {

        BoxGeometry: function ( mesh ) {

          const data = {
            width: 15,
            height: 15,
            depth: 15,
            widthSegments: 1,
            heightSegments: 1,
            depthSegments: 1
          };

          function generateGeometry() {

            updateGroupGeometry( mesh,
              new BoxGeometry(
                data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments
              )
            );

          }

          const folder = gui.addFolder( 'THREE.BoxGeometry' );

          folder.add( data, 'width', 1, 30 ).onChange( generateGeometry );
          folder.add( data, 'height', 1, 30 ).onChange( generateGeometry );
          folder.add( data, 'depth', 1, 30 ).onChange( generateGeometry );
          folder.add( data, 'widthSegments', 1, 10 ).step( 1 ).onChange( generateGeometry );
          folder.add( data, 'heightSegments', 1, 10 ).step( 1 ).onChange( generateGeometry );
          folder.add( data, 'depthSegments', 1, 10 ).step( 1 ).onChange( generateGeometry );

          generateGeometry();

        },


      };

      function chooseFromHash( mesh ) {

        const selectedGeometry = window.location.hash.substring( 1 ) || 'BoxGeometry';

        if ( guis[ selectedGeometry ] !== undefined ) {

          guis[ selectedGeometry ]( mesh );

        }

        if ( selectedGeometry === 'TextGeometry' ) {

          return { fixed: true };

        }

        //No configuration options
        return {};

      }

      //

    //   document.getElementById( 'newWindow' ).href += window.location.hash;

      const gui = new GUI();

      const scene = new Scene();
      scene.background = new Color( 0x444444 );

      const camera = new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );
      camera.position.z = 30;

      const renderer = new WebGLRenderer( { antialias: true } );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      const orbit = new OrbitControls( camera, renderer.domElement );
      orbit.enableZoom = false;

      const lights = [];
      lights[ 0 ] = new PointLight( 0xffffff, 1, 0 );
      lights[ 1 ] = new PointLight( 0xffffff, 1, 0 );
      lights[ 2 ] = new PointLight( 0xffffff, 1, 0 );

      lights[ 0 ].position.set( 0, 200, 0 );
      lights[ 1 ].position.set( 100, 200, 100 );
      lights[ 2 ].position.set( - 100, - 200, - 100 );

      scene.add( lights[ 0 ] );
      scene.add( lights[ 1 ] );
      scene.add( lights[ 2 ] );

      const group = new Group();

      const size = 40;
      const divisions = 10;

      const gridHelper = new GridHelper(size, divisions,'dodgerblue','lightgray');
      scene.add(gridHelper);


      const geometry = new BufferGeometry();
      geometry.setAttribute( 'position', new Float32BufferAttribute( [], 3 ) );

      const lineMaterial = new LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.5 } );
      const meshMaterial = new MeshPhongMaterial( { color: 0x156289, emissive: 0x072534, side: DoubleSide, flatShading: true } );

      group.add( new LineSegments( geometry, lineMaterial ) );
      group.add( new Mesh( geometry, meshMaterial ) );

      const options = chooseFromHash( group );

      scene.add( group );

      function render() {

        requestAnimationFrame( render );

        if ( ! options.fixed ) {

          group.rotation.x += 0.005;
          group.rotation.y += 0.005;

        }

        renderer.render( scene, camera );

      }

      window.addEventListener( 'resize', function () {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }, false );

      render();

    </script>
  </body>
</html>



########## 클래스 GUI
class AxisGridHelper {
  constructor(node, units = 10) {
    const axes = new THREE.AxesHelper();
    axes.material.depthTest = false;
    axes.renderOrder = 2;  // 격자 다음에 렌더링
    node.add(axes);
 
    const grid = new THREE.GridHelper(units, units);
    grid.material.depthTest = false;
    grid.renderOrder = 1;
    node.add(grid);
 
    this.grid = grid;
    this.axes = axes;
    this.visible = false;
  }
  get visible() {
    return this._visible;
  }
  set visible(v) {
    this._visible = v;
    this.grid.visible = v;
    this.axes.visible = v;
  }
}

  function makeAxisGrid(node, label, units) {
    const helper = new AxisGridHelper(node, units);
    gui.add(helper, 'visible').name(label);
  }

  makeAxisGrid(solarSystem, 'solarSystem', 26);





#######  FACE api

> 웹캠 영상 불러오기 > 리얼센스 웹캠으로 사용하기(장치관리자에서 Depth Camera 사용안함 선택)

<video src="" id="video" width="720" height="560" autoplay muted></video>

-------------------------------
<script defer>
    const video = document.querySelector('video');

    function startVideo(){
        navigator.getUserMedia(
            {video:{}},
            stream =>video.srcObject = stream,
            err=>console.error(err)
        )
    }

    startVideo();
</script>

----------------------------------
--------------------------------------------------

보완코드
>navigator.getUserMedia() 함수는 deprecated 판정을 받아 navigator.mediaDevices.getUserMedia() 라는 함수로 대체하여 사용해야만 한다.
>getUserMedia 함수는 프라미스를 반환하는데, 프라미스를 통해 웹캠을 조작

function startVideo() {
  navigator.mediaDevices
    .getUserMedia({ video: true })
    .then(function (stream) {
      video.srcObject = stream;
    })
    .catch(function (err) {
      console.log(err);
    });
}
--------------------------------------------------
캔버스를 만들어 붙이다
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    document.body.appendChild(ctx.canvas);
    ctx.canvas.width = 300;
    ctx.canvas.height = 300;




 <style>
     body{
         margin: 0;
         padding: 0;
         width: 100vw;
         height: 100vh;
         display: flex;
         justify-content: center;
         align-items: center;
     }
     video{
         filter: sepia(1);
         /* clip-path: circle(30% at 50% 65%); */
         /* transform: scaleX(-1); */
         /* animation: myRotate 5s infinite linear; */
     }
     /* video:hover{
         filter: sepia(0);
         transform: translate(0,-50px);
     } */

     @keyframes myRotate{
         from{
             transform: rotate3d(0,1,0,0);
         }
         to{
             transform: rotate3d(0,1,0,1turn);

         }
     }
     .text{
         position: absolute;
         font-size: xx-large;
         color: silver;
         font-weight: bold;
         /* text-shadow: 1px 1px 5px white; */
     }
 </style>






> 얼굴인식 api 로딩
<script defer src="./js/face-api.min.js"></script>


>> 병렬 비동기 방식으로 실행 > Promise.all (프라미스: API 클래스) 요소 전체가 프라미스인 배열을 받고 새로운 프라미스를 반환합니다

----------------------------------------------------------------------------------------------
프로미스

> 프로미스를 사용하지 않은 예
async function test(){
    await foo(1, 2000)
    await foo(2, 500)
    await foo(3, 1000)
}

function foo(num, sec){
    setTimeout( function(){
        console.log(num);
    }, sec);
}

test();

결과> 2  3  1

> 프로미스를 사용한 예
async function test(){
    await foo(1, 2000)
    await foo(2, 500)
    await foo(3, 1000)
}

function foo(num, sec){
    return new Promise(function(resolve, reject){
        setTimeout( function(){
            console.log(num);
            resolve("async는 Promise방식을 사용합니다.");
        }, sec);
    });
}
test();

결과> 1  2  3


######  Promise 2
//promise 는 조건이 맞으면 resolve를 return 하고 아니면 reject를 return한다

function makeRequest(location){
    return new Promise((resolve, reject)=>{
        console.log(`Making Request to ${location}`)
        if(location==='Google'){
            resolve('Google says hi')
        }else{
            reject(`We can only talk to Google`)
        }
    })
}

function processRequest(response){
    return new Promise((resolve, reject)=>{
        console.log(`Processing response`)
        resolve(`Extra Informaton + ${response}`)
    })
}


//async를 사용하지 않는 방법

// makeRequest('Google').then(response=>{
//     console.log(`응답받음`)
//     return processRequest(response)
// }).then(processResponse=>{
//     console.log(processResponse)
// }).catch(err=>{
//     console.log(err)
// })


//async를 사용하는 방법

async function doWork(){
    try{
        const response = await makeRequest('Google')
        console.log('Response Received')
        const processResponse = await processRequest(response)
        console.log(processResponse)
    } catch(err){
        console.log(err)
    }
}
doWork()






----------------------------------------------------------------------------------------------

> tinyFaceDetector : 작은 얼굴 감지기를 사용하여 이미지에서 모든 얼굴을 감지하려고 합니다.


---------------------------------------------------------------------
#######  AgeGender
> models 폴더에 age_gender_model-shard1, age_gender_model-weights_manifest.json  파일 넣기

>> CSS
     }
     canvas {
      position: absolute;
    }


>>  Script

const video = document.getElementById('video')

Promise.all([
  faceapi.nets.tinyFaceDetector.loadFromUri('./models'),
  faceapi.nets.faceLandmark68Net.loadFromUri('./models'),
  faceapi.nets.faceRecognitionNet.loadFromUri('./models'),
  faceapi.nets.faceExpressionNet.loadFromUri('./models'),
  faceapi.nets.ageGenderNet.loadFromUri('./models'),
  
]).then(startVideo)

function startVideo() {
  navigator.getUserMedia(
    { video: {} },
    stream => video.srcObject = stream,
    err => console.error(err)
  )
}

video.addEventListener('play', () => {
  const canvas = faceapi.createCanvasFromMedia(video)
  document.body.append(canvas)
  const displaySize = { width: video.width, height: video.height }
  faceapi.matchDimensions(canvas, displaySize)
  setInterval(async () => {
    const detections = await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceExpressions().withAgeAndGender()
    const resizedDetections = faceapi.resizeResults(detections, displaySize)
    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height)
    faceapi.draw.drawDetections(canvas, resizedDetections)
    faceapi.draw.drawFaceLandmarks(canvas, resizedDetections)
    faceapi.draw.drawFaceExpressions(canvas, resizedDetections)
    // resizedDetections.forEach(result=>{
    //     const {age, gender, genderProbability}=result;
    //     new faceapi.draw.DrawTextField(
    //         [
    //             `${faceapi.round(age,0)} years`,
    //             `${gender} (${faceapi.round(genderProbability)})`
    //         ],
    //         result.detection.box.bottomRight
    //     ).draw(canvas);
    // })
    resizedDetections.forEach( detection => {
      const box = detection.detection.box
      const drawBox = new faceapi.draw.DrawBox(box, { label: Math.round(detection.age) + " year old " + detection.gender })
      drawBox.draw(canvas)
    })

  }, 100)
})




##########  캔버스를  재질로
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #c{
            display: block;
            width: 600px;
            height: 300px;
            border: 1px solid #000;
        }
    </style>
</head>
<body>
    <video src="" width="512" height="512" autoplay muted></video>
    <canvas id="c"></canvas>

    <script type="module">
        const video = document.querySelector('video')
        function startVideo(){
            navigator.mediaDevices.getUserMedia({video})
            .then(stream=>video.srcObject= stream)
            .catch(err=>console.log(err))
        }
        startVideo()

        const ctx = document.createElement('canvas').getContext('2d')
        ctx.canvas.width = 200
        ctx.canvas.height = 200
        document.body.appendChild(ctx.canvas)
        ctx.canvas.style.border='1px solid red'
        ctx.fillStyle = 'red'
        ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height)
        
        const img = new Image()
        img.addEventListener('load',()=>{
            ctx.drawImage(img, 10,10, 180,180)
        })
        img.src='../photo.png'


        import * as THREE from './js/three.module.js'

        let texture, cube, renderer, canvas, camera, scene

        function init(){
            canvas = document.querySelector('#c')
            renderer = new THREE.WebGLRenderer({canvas})

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, 2, 1,10)
            camera.position.set(0,0,2)

            {
                const light = new THREE.DirectionalLight(0xffffff, 1)
                light.position.set(-1,2,4)
                scene.add(light)
            }

            const geometry = new THREE.BoxGeometry(1,1,1)

            // texture = new THREE.CanvasTexture(ctx.canvas)
            texture = new THREE.VideoTexture(video)
            const material = new THREE.MeshPhongMaterial({
                map:texture
            })
            // const material = new THREE.MeshPhongMaterial({color:'red'})
            
            cube = new THREE.Mesh(geometry, material)
            scene.add(cube)

        }

        function resizeRendererToDisplaySize(renderer){
            const canvas = renderer.domElement
            const width = canvas.clientWidth
            const height = canvas.clientHeight
            
            const needResize = width!==canvas.width||height!==canvas.height

            if(needResize){
                renderer.setSize(width,height,false)
            }

            return needResize
        }

        function animate(time){
            time *=0.001

            if(resizeRendererToDisplaySize(renderer)){
                camera.aspect = canvas.width/canvas.height
                camera.updateProcjectionMatrix()
            }
            texture.needsUpdate = true

            cube.rotation.set(time,time,0)

            renderer.render(scene, camera)

            requestAnimationFrame(animate)
        }
        
        init()
        requestAnimationFrame(animate)
        animate()


    </script>
    
</body>
</html>





############## canvas 생성하여 넣기 ctx
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.canvas.width = 300;
        ctx.canvas.height = 300;
        document.body.appendChild(ctx.canvas);
        ctx.strokeRect(10,20,100,100);


############## three renderer 생성하여 넣기
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(600, 300);
            document.body.appendChild(renderer.domElement)



