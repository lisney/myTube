<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        #c{
            display: block;
            width: 600px;
            height: 300px;
        }
    </style>
</head>
<body>
    <video src="" width="300" height="300" autoplay muted></video>
    <canvas id="c"></canvas>

    <script type="module">
        const video = document.querySelector('video')
        function startVideo(){
            navigator.mediaDevices.getUserMedia({video})
            .then(stream=>video.srcObject = stream)
            .catch(err=>console.log(err))
        }
        startVideo()

        //캔버스 2D
        const ctx = document.createElement('canvas').getContext('2d')
        ctx.canvas.width = 300
        ctx.canvas.height = 300
        document.body.appendChild(ctx.canvas)

        ctx.fillStyle = 'red'
        ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height)

        const img = new Image()
        img.addEventListener('load',()=>{
            ctx.drawImage(img, 10, 10, ctx.canvas.width-20, ctx.canvas.height-20)
        })
        img.src = '../4g2.jpg'

        //three JS
        import * as THREE from './three.module.js'

        const canvas = document.querySelector('#c')
        let renderer, texture, scene, cubes, camera

        function main(){
            renderer = new THREE.WebGLRenderer({canvas})
            scene = new THREE.Scene()
            scene.background = new THREE.Color(0x555555)

            camera = new THREE.PerspectiveCamera(75, 2, 1, 10)
            camera.position.set(0,0,2)
            {
                const light = new THREE.DirectionalLight(0xffffff, 1)
                light.position.set(-1,2,4)
                scene.add(light)
            }

            const geometry = new THREE.BoxGeometry(1,1,1)

            function rand(min, max){
                if(max ===undefined){
                    max = min
                    min = 0
                }
                return min + (max -min)*Math.random()
            }
            texture = new THREE.CanvasTexture(ctx.canvas)
            const textureVideo = new THREE.VideoTexture(video)

            function makeInstance(x){
                const material = [
                        new THREE.MeshPhongMaterial({color:`hsl(${rand(360)|0}, ${rand(50,100)|0}%, 50%)`}),
                        new THREE.MeshPhongMaterial({map: texture}),
                        new THREE.MeshPhongMaterial({color:`hsl(${rand(360)|0}, ${rand(50,100)|0}%, 50%)`}),
                        new THREE.MeshPhongMaterial({map: texture}),
                        new THREE.MeshPhongMaterial({map: textureVideo}),
                        new THREE.MeshPhongMaterial({color:`hsl(${rand(360)|0}, ${rand(50,100)|0}%, 50%)`}),
                    ] 

                const cube = new THREE.Mesh(geometry, material)
                cube.position.set(x,0,0)
                scene.add(cube)

                return cube
            }

            cubes =[
                makeInstance(-2),
                makeInstance(0),
                makeInstance(2),
            ]

            function resizeRendererToDisplaySize(renderer){
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;

                const needResize = width!==canvas.width||height!==canvas.height;

                if(needResize){
                    renderer.setSize(width, height, false)
                }

                return needResize
            }

            function render(time){
                time *= 0.001

                if(resizeRendererToDisplaySize(renderer)){
                    camera.aspect = canvas.width/canvas.height;
                    camera.updateProjectionMatrix()
                }

                cubes.forEach((c,i)=>{
                    const speed = 1 + i*.1
                    const rot = speed *time

                    c.rotation.set(rot,rot,0)
                })
                texture.needsUpdate = true

                renderer.render(scene, camera)

                requestAnimationFrame(render)
                
            }
            requestAnimationFrame(render)

        }

        main()
        
        // const pickPosition = {x:-1, y:-1}
        let pickPosition = new THREE.Vector2()
        const domRect = canvas.getBoundingClientRect()

        function choose(event){
            let Sx = event.clientX -domRect.x
            let Sy = event.clientY -domRect.y
            pickPosition.x = (Sx/canvas.width)*2 -1;
            pickPosition.y = (Sy/canvas.height)*-2 +1

            let raycaster = new THREE.Raycaster()
            raycaster.setFromCamera(pickPosition, camera)
            let intersects = raycaster.intersectObjects(scene.children)
            console.log(domRect.width,intersects)

            if(intersects.length>0){
                intersects[0].object.material[1].transparent = true
                intersects[0].object.material[2].side = THREE.DoubleSide
                intersects[0].object.material[1].opacity = 0.4
            }

        }

        canvas.addEventListener('click', choose)



    </script>
</body>
</html>
프로미스
========

function makeRequest(location){
    console.log(`${location} 전달`)
    return new Promise((resolve, reject)=>{
        if(location ==='Google'){
            resolve('구글 전달')
        }else{
            reject('니주글래')
        }
    })
}

function processRequest(response){
    return new Promise((resolve, reject)=>{
        resolve(`${response}를 받았다`)
    })
}

async function doWork(){
    try{
        const response = await makeRequest('Gogle')
        console.log(response)
        const processResponse = await processRequest(response)
        console.log(processResponse)
    }catch(err){
        console.log(err)
    }
}
doWork()
